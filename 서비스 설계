ㅇ MSA는 기본적으로 분산 시스템 설계이다. 타 서비스간에는 네트웍크를 통해서만 연계가 가능하므로 실행환경 및 회복성을 고려하여 설계
ㅇ 자체 아키텍처와 기술스택 적용이 가능해야함.

ㅇ 서비스 연계 설정
   - intenal 서비스 연계 : 마이크로서비스 내부에서 타 마이크로서비스 간의 상호 작용
   - external 서비스 연계 : External 서비스 연계 Layer에서 마이크로 서비스들의 상호작용 설계
   
   1. MS의 통신메카니즘
      . 서비스 내에서는 함수 호출이지만 서비스간에는 REST를 통한 동기식/비동기식 통신
      1) 동기식
          - 요청후 응답이 적시에 도착할 것으로 기대
          - 이벤트 블럭이 발생하고 서비스가 밀접하게 연계되어 있음. 
          - HTTP기반의 REST방식
      2) 비동기식 메세지 기반 통식
          - 요청 후 이벤트 블럭이 발생하지 않고 즉각적인 응답을 기대하지 않음.
          - 서비스가 느슨하게 연결된 경우
          - Message Queue이용 구현
   2. 장애 발생시 대응
      . MS간 동기식 요청을 보낼때 실패가 발생하면 처리하는 방식
      . Circuit break 패턴
         - 실패한 요청수를 기록하여 특정 임계값이 넘으면 바로 실패를 리턴하고, 일정 시간이 지난 후 다시 요청.
         - 응답을 받을 수 없을때 처리방안
             1) 오류를 반환하여 사용자에게 실패를 확실히 알려주는 방법
             2) 기본값이나 Cache된 응답을 반환해주는 fallback함수를 설계하여 사용자에게 리턴하여 사용자는 실패를 인지하지 못하고 실행
             3) 응답 받을 수 없는 시점의 요청을 queue에 넣어 나중에 처리
       
   4. 다중 MS Data Query
      . MSA에서는 조인을 사용할 수 없기 때문에 API Composition패턴과 CQRS패턴을 이용하여 설계
      1) API Composition 패턴
       . 여러 MS에서 API로 데이터를 가지고 와서 통합하는 패턴임.
       . 이 패턴은 애플리케이션 복잡도를 높히고 성능에 영향을 줌.
       . 별도의 응답 data를 composition할 수 있는 F/W이 필요함.
       . 대량의 응답 Data가 예상되는 경우에는 적합하지 않음.
      2) CQRS(Common Query Responsinility Segregation) 패턴
        . MSA에서 상태변경(Common)와 조회(Query)할때 동일 도메인 모델, 즉 하나의 서비스를 사용하면 조회기능 구현시 복잡해지고 속도에 문제 발생
        . CQRS는 상태변경과 조회의 서비스를 분리하여 구현의 복잡도를 낮춤.
        . 상태변경 서비스와 조회서비스간의 동기화는 Message Queue를 이용.
  
  5. MS간 트랜잭션 설계
    . MS간 트랜잭션은 기존 RDBMS의 ACID가 아닌, BASE(Basically Avaiable, Soft state, Eventually consistent)라는 개념으로 설계하고 
      Eventually Consistent를 보장하도록 해야 함.
      
      1) 2Phase Commit
        . 분산환경에서는 2PC를 구현할 수있지만 MSA에서는 권장하지 않음. 이유는
          1) 2PC를 지원하지 않는 DBMS
          2) 최신 메세지 브로커도 지원하지 않음.
          3) 이기종간 DBMS는 지원안됨.
          4) 2PC를 하려면 트랜잭션 참여하는 모든 서비스가 가용상태여야 함.(전체적인 가용성을 떨어뜨림)
        . 2PC가 필요한 트랜잭션은 하나의 서비스로 정련할 수 있는 지 고려해 봐야함.
       
       2) 취소 프로세스에 의한 처리
        . 트랜잭션 오류가 발생을 하면 사용자가 취소할 수 있는 프로세스를 설계하는 방식.
        . 하나의 트랜잭션을 여러번 작업해야 하기 때문에 고객의 합의가 필요
       
       3) 보상 트랜잭션
         . ACID트랜잭션은 트랜잭션이 쉽게 롤백이 되지만 MSA에서는 각 서비스에서 commit이 발생하기 때문에 자동 롤백이 될수 없다.
         . MSA에서는 트랜잭션 처리 도중 실패가 발생하면 명시적으로 이전단계의 변경사항을 취소할 수 있는 역방향 트랜잭션이 설계되어야 함.
         . MSA에서 데이터의 일관성을 유지하기 위한 패턴이 Saga패턴.
         . saga패턴은 각 MS의 로컬 트랜잭션은 ACID를 보장하고, 로컬 트랜잭션 완료 후 다음 MS의 로컬 트랜잭션을 트리거함.
         . 실패시 보상트랜잭션을 통해 Eventually Consistent가 보장되도록 하는 패턴임.
         a) Orchestration-based Saga
            . Commond 방식으로 Command를 주도하는 Master(Saga Orchestrator)가 전체적인 트랜잭션을 관리함.
            . 트랜잭션이 발생하면 서비스에서 로컬 트랜잭션을 수행 후 성공여부를 Saga Orchestrator에게 전달함
              (Saga Orchestrator는 요청한 서비스에 위치함)
            . 성공하면 다음 Message를 발행함.
            . 실패하면 보상 트랜잭션을 역순으로 호출함.
         b) Choreography-based Saga
            . Event방식으로 Saga에 참여한 서비스들은 Message Queue를 이용하여 서로의 이벤트를 구독하고, 수행결과를 이벤트로 발행함.
            . 트랜잭션 성공시 성공 event를 발행하고 실패시 보상 트랜잭션을 발생하는 event를 발행함.
            . 실패시 이벤트를 전체적으로 발해하면 복잡하고 이벤트 루프가 발생할 수 있기 때문에 정상트랜잭션의 반대 방향으로 하나씩 발행
              하는 것이 좋음.               
         c) Tranastion Audit Log
            . 오류 발생시 Transaction Audit Log를 기록하고 주기적으로 보정처리 배치를 통항 보상 트랜잭션을 수행함.
       4) 무시
          . MS간 정합성이 보장 안되는걸 인정하고 발생하는 손실은 비즈니스 손실을 감안하는 경우
   6. 공유 커널 설계
     . Shared Kernel로 선정된 경우 여러 MS와 Data공유가 필요하며 적절한 공유 방법은 선택하여 진행.
